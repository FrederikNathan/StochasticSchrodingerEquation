from numpy import *
import numpy.random as npr
from scipy.linalg import *
from scipy.sparse import *
import datetime
import time
import os
import sys
import logging as l
import numpy.fft as fft
import _pickle as pickle

import NoiseSimulationFunctions as NSF
from NoiseSimulationFunctions import *

import BasicFunctions as BF
from BasicFunctions import *

#from matplotlib.pyplot import *

#==============================================================================
# Stochastic Schrodinger Equation (SEE) evolution
# 
# Computes the time-evolution of an initial state with the SSE. 
# The evolution takes place in a rotating frame (see notes), 
# and is generated by 
#
#   Ueff = e^{-i\int_0^t dt' (Heff  - 1/2 i D(t'))}
# 
# Here, the ``decay operator'' is given by 
#
#   D(t)= \sum^{(n)}\int dW J(W) L^{*n}_W(t) L^n_W(t)
#
# where n indicates the type of decay (Cavity, Sx, Sy, and Sz),
# and L_W(t) is the jump operator (in the rotating frame)
#
# The script generates the data PsiList, and tlist, that determine the 
# evolution of the system's wave function for this realization of the  
# Stochastic Schrodinger equation. 
#
# The data PsiList gives the time evolution fo the wave function in the
# rotating rame,  in the basis of Floquet eigenstates.
# Specifically, the evolution of the state |\Psi(t)> is given by
# 
#   |Psi(t)>=Q(t)\sum_a |\phi_a>\Psi_a(t),
# 
# where
# 
#   Q(t) = U(t)e^{iH_{eff} t} 
#
# is the micromotion operator. |\phi_a> is the a'th Floquet eigenstate, and 
# 
#   \Psi_a[t_n] = PsiList[n]
#
# where t_n=tlist[n].
#
# In addition to generating the wave function, the script saves a list of the
# decay events (DecayList), recording time, frequency and type of the event.
#
#==============================================================================

# Details of initial state
n0=100
sigma=sqrt(n0)
s=-1

InitializationNotes="Spin %s, n0=%d eta positive"%(str(s),n0)
CreateNewData=True

#==============================================================================
# 0: Initialization
#==============================================================================

# ID for run
RunID="%s_%d_%s_"%(RunID_gen(),n0,str(s))

# script can be launched with ArgV. Otherwise, specify parameters here. (See below for explanation of parameters)
if not len(sys.argv)>2:
    sys.argv[1:]=[400  ,1.618033988750,0.5*pi, 10,   10 ,        0.0008,     0.00,    300,       0,        16,    -12, 5000]#,     100         ,0.05]
                # N, ratio,        eta,  A_2,  M,   gamma_c, gamma_s,   Res_drive, Nres_out, N_trotter,  treshlog, Nperiods 
    OutputToConsole=True # Direct output to console (instead of log files). 
elif len(sys.argv)==2:
    K=str(sys.argv[1])
    if K=="Log":
        OutputToConsole=True
    else:
        raise ValueError("Input must be 'Log' to give log to file")
    
else:
    OutputToConsole=False



LogFile="../Logs/SSE/"+RunID+".log"
l.basicConfig(filename=LogFile,filemode="w",format='%(message)s',level=l.DEBUG)


BF.OutputToConsole=OutputToConsole
BF.__init__()


#==============================================================================
# 1: Input Parameters
#==============================================================================

### A: System parameters
N     = int(sys.argv[1])         # size of lattice (# of photon states)
ratio = float(sys.argv[2])       # 1.61803398875
eta   = float(sys.argv[3])       # 5*pi     # coupling between spin and field
A_2   = float(sys.argv[4])       # Amplitude of driving field
M     = float(sys.argv[5])       # Magnetic field

omega2=2*pi;                     # Frequency of driving field
omega1=omega2/ratio;             # Frequency of cavity mode

gamma_c=float(sys.argv[6]) #15      # CouplingConstant of cavity
gamma_s=float(sys.argv[7]) #7       # CouplingConstant of spin
 
NT                  = int(sys.argv[12])    # Periods to evolve over


### B: Time resolution parameters (see NSF for explanation)
Resolution_drive    =   NSF.Resolution_drive   
Dt_out              =   NSF.Dt_out
N_trotter           =   NSF.N_trotter 

# Time interval between time evolution steps 
dt                  = 1/(Resolution_drive*2**(Nres_out))

# Time interval for trotterization
dtau                = dt/(2**N_trotter)

# Number of time-evolution steps
TimeSteps           = Resolution_drive*(2**Nres_out)



## C: Jump operator resolution parameters (see NSF for details)
Resolution_jump     = int(NSF.Resolution_jump+0.1) # Time resolution of jump operator 
Res_SSE             = NSF.Res_SSE       # Number of jump attempts per driving period. 

# Time interval in which jump operators are assumed constant
DT_J=1/NSF.Resolution_jump

# Number of times per DT_J-interval, in which jumps are attempted 
N_att               = int(Res_SSE/Resolution_jump+0.1)

# Total number of output times
Nout = int(NT/Dt_out+0.999)   # Total number of output data points



# Time interval between jump attempts
DT_att=DT_J/N_att #0.05 # Time step for SEE evolution     


# List with parameters to save 
parameters=[N,ratio,eta,A_2,M,gamma_c,gamma_s,Resolution_drive,Nres_out,
            N_trotter,treshlog,NT,Resolution_jump,Res_SSE]
           
explanation="parameters are: [N,ratio,eta,A_2,M,gamma_c,gamma_s,Resolution_drive,Nres_out,N_trotter,tresh (log10),Resolution_jump,Res_SSE"

Operators=["Cavity","Sx","Sy","Sz"]


#==============================================================================
# 2: Load input data
#==============================================================================

# Argument to be passed to jump operator script if necessary
Args=[ N, ratio,  eta,  A_2,  M]
 
# System parameter directory  
JumpOperatorDir="../Data/JumpOperators/"+FloquetDir_gen(N,ratio,eta,A_2,M,Resolution_drive,Nres_out)+"/"

# Resolution parameter directory 
InputDir=JumpOperatorDir#ParmDir+ResDir_gen(Resolution_drive,Nres_out,nW,NT_J,CutoffRel,NBlocksW)+"/"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# 2.1: Load processed data 
Log("Looking for jump operators")
InputData=DataSearch(InputDir+"Data.npz","JumpOperatorGeneratorNew.py",Args,CreateNewData=CreateNewData)



Eigenvectors=InputData["Eigenvectors"]
QE=InputData["QE"]

freqvec=InputData["freqvec"]

Freqs=omega2*freqvec

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# 2.2 Load ``raw'' data

# Jump operator spectra
JOS_Cavity    = load_pickle(InputDir+"JOS_Cavity.dat")
JOS_Sx        = load_pickle(InputDir+"JOS_Sx.dat")
JOS_Sy        = load_pickle(InputDir+"JOS_Sy.dat")
JOS_Sz        = load_pickle(InputDir+"JOS_Sz.dat")

# Decay operators
DC           = gamma_c*load_pickle(InputDir+"Heff_Cavity.dat")
DX           = gamma_s*load_pickle(InputDir+"Heff_Sx.dat")
DY           = gamma_s*load_pickle(InputDir+"Heff_Sy.dat")
DZ           = gamma_s*load_pickle(InputDir+"Heff_Sz.dat")

# Net decay operator
DecayOperatorList = DC+DX+DY+DZ

AnnihilationOperator=NSF.AnnihilationOperator(N)
PhotonCountOperator=AnnihilationOperator.conj().T.dot(AnnihilationOperator)
PhotonCountOperator=Eigenvectors.conj().T.dot(PhotonCountOperator.dot(Eigenvectors))



#==============================================================================
# 3: Initialization before time evolution 
#==============================================================================

### A: Initial state 
Psi0=GaussianPacketGenerator(N,n0,s,sigma,0)

# Changing to basis of Floquet eigenstates 
Psi0=(Eigenvectors.conj().T).dot(Psi0)

#Log("NB!!! projecting Psi into subspace without excluded elements")
#Psi0[ExcludeElements]=0

### B: List with effective time evolutions 
UeffList=zeros((2*N,2*N,Resolution_jump),dtype=complex)


Log("Constructing Ueff")
tnow0=time.time()
for nJ in range(0,Resolution_jump):
    if (nJ%10)==0:
        Log("    At time step %d/%d"%(nJ,Resolution_jump))

    Heff=-0.5j*DecayOperatorList[:,:,nJ]+diag(QE)

    Ueff=expm(-1j*DT_att*Heff)
    
    UeffList[:,:,nJ]=Ueff
    
        
Log("    Done. Time spent: %.2f s"%(time.time()-tnow0))   


### D: Defining dynamical lists and variables   
Psi=Psi0            # Instantaneous state

tlist       = []    # List with recording times 
DecayList   = []    # List with decay events 

# List with wavefunction evolution
PsiList     = zeros((2*N,Nout),dtype=complex)

# Counter for number of recording instances 
nOut=0


#==============================================================================
# 4: Time-evolution
#==============================================================================

t=0
tout_last=1

# Functions used to save data from current state (to be called repeatedly during iterative solution). 
def SaveFunc():     

    OutputDir="../Data/InteractionPictureEvolutions/"+ParmDir_gen(N,ratio,eta,A_2,M,gamma_c,gamma_s)+"/"

    try:
        os.mkdir(OutputDir)
    except FileExistsError:
        pass
    
    OutputPath=OutputDir+RunID+".npz"
    savez(OutputPath,PsiList=PsiList,tlist=tlist,parameters=parameters,
          explanation=explanation,DecayList=DecayList,Nsteps_out=Nout,
          QE=QE,Eigenvectors=Eigenvectors,
          InitializationNotes=[InitializationNotes])
    
    Log("")
    Log("Data saved at %s"%OutputPath)   
    Log("")
    return 

# Driving period

Log("Evolving")
tnow=time.time()
tnowSave=time.time()


for nT in range(0,NT):
    
    # Save every 30 minutes
    if time.time()-tnowSave>1800:
        SaveFunc()
        tnowSave=time.time()
    
    # nT : which number of periods we have evolved for already 
    
    # Display progress every 5 driving periods
    if nT%5==0:
        Log("At time step %d/%d"%(nT,NT))
        
        Nphotons=ExpVal(PhotonCountOperator,Psi)

        Log("    Photon number   : %.2f  "%real(Nphotons))
        Log("    CPU time so far : %.2f s"%(time.time()-tnow))
        
        if Nphotons<10:
            savez("../Warnings/"+"Warning_%d_%s.npz"%(nT,RunID),nT)

        

    # Iterate over steps, in each of which the jump operator is assumed constant
    for nJ in range(Resolution_jump):
        

        
        ### B: Evolve state with effective evolution 
        
        # Evolution and decay operator for this jump-operator time block        
        Ueff=UeffList[:,:,nJ]
        
        # Decay operator D= \sum_k L^*_k L_k )
        D=DecayOperatorList[:,:,nJ]
        dc=DC[:,:,nJ]
        dx=DX[:,:,nJ]
        dy=DY[:,:,nJ]
        dz=DZ[:,:,nJ]
        
        # Iterate over the attempt time intervals 
        for n_att in range(0,N_att):

            # Current time 
            t=nT+nJ*DT_J+n_att*DT_att
            
            ### A: Record output every tout time-interval
            if t%Dt_out<tout_last:
                
                
                # Time of recording
                tlist.append(t)             
    
                # Record wave function
                PsiList[:,nOut]=Psi[:,0]    
    
                nOut+=1
        
            tout_last=t%Dt_out
  
            Psi=Ueff.dot(Psi) # Evolve Psi
            Psi=Psi/norm(Psi) # Normalize
            


            ### C: Check for decay

            # Calculate probability for decay in time-interval t,t+DT_att            
            Q = DT_att*abs(ExpVal(D,Psi))
            
            # Random number in [0,1] used to stochastically decide if decay should occur.
            R=npr.rand()

            # For decay to happen, R must be < Q
            if R<Q:

                # Determine whether decay happens in cavity or either of the 3 spin channels:
                
                QC=abs(DT_att*ExpVal(dc,Psi))
                
                # Check if decay is in cavity channel
                if R<QC:
                    DecayType="Cavity"                  
                    L=NSF.JumpOperatorExtractor(JOS_Cavity,t,Freqs)

                else:
                    
                    QX=abs(DT_att*ExpVal(dx,Psi))
                    
                    # Check if decay is in SX channel
                    if R<QC+QX:
                        DecayType="Sx"
                        L=NSF.JumpOperatorExtractor(JOS_Sx,t,Freqs)
                        
                    # Check if decay is in SY  channel
                    else:
                        QY=abs(DT_att*ExpVal(dy,Psi))
                        
                        if R<QC+QX+QY:
                            DecayType="Sy"
                            L=NSF.JumpOperatorExtractor(JOS_Sy,t,Freqs)

                        # Otherwise, decay must be in SZ channel
                        else:
                            DecayType="Sz"
                            L=NSF.JumpOperatorExtractor(JOS_Sz,t,Freqs)
                                                
                # Evolve wavefunction with cdecay operators                             
                PsiOld=Psi                             
                Psi=L.dot(Psi)
                Psi=Psi/norm(Psi) 
                Nphotons=ExpVal(PhotonCountOperator,Psi)                           
                   
                # Add decay event to list of decay events 
                DecayStats=[t,DecayType,"Time, Type"]
                DecayList.append(DecayStats)       

             
                    
# Saving data one last time.                 
SaveFunc()                 
                    

